{
  "filename": "filter-intro.md",
  "__html": "<h2><strong>Filter的生命周期</strong></h2>\n<p>Pixiu作为一个面向云原生的gateway，通过简单的配置即可代理Http to Dubbo 2、Tripe甚至是Spring Cloud的请求。那Filter是怎样运行的呢？</p>\n<p>首先<strong>Filter Plugin</strong>向<strong>Filter Manager</strong>注册自己**，<strong>然后</strong>Filter Manager<strong>根据配置创建好</strong>Filter Factory<strong>并持有它们，等待请求来临时，<strong>Manager</strong>创建一个一次性的用于此次请求的Filter Chain，然后利用</strong>Factory<strong>创建好</strong>Decode/Encode Filter<strong>并把它们加入链中，然后按照顺序去运行Decode Filter，然后去请求</strong>Upstream**，拿到Response再反向运行Encode Filter，让Filter可以访问到Response。</p>\n<p>几个关键的概念：</p>\n<p><strong>Filter Manager</strong></p>\n<blockquote>\n<p>Filter的Manger。。。</p>\n</blockquote>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// FilterManager manage filters</span>\n<span class=\"hljs-keyword\">type</span> FilterManager <span class=\"hljs-keyword\">struct</span> {\n   filters       <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]HttpFilterFactory\n   filtersArray  []*HttpFilterFactory\n}\n</code></pre>\n<p><strong>Filter Plugin</strong>：定义了Filter的（唯一的）名字和描述如何去创建一个Filter Factory。</p>\n<blockquote>\n<p>其实结合Filter Factory的定义，可以认为Plugin是Filter Factory的Factory</p>\n</blockquote>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// HttpFilterPlugin describe plugin</span>\nHttpFilterPlugin <span class=\"hljs-keyword\">interface</span> {\n   <span class=\"hljs-comment\">// Kind returns the unique kind name to represent itself.</span>\n   Kind() <span class=\"hljs-keyword\">string</span>\n\n   <span class=\"hljs-comment\">// CreateFilterFactory return the filter factory</span>\n   CreateFilterFactory() (HttpFilterFactory, error)\n}\n</code></pre>\n<p><strong>Filter Factory</strong>：定义了Filter自身的配置，并且在请求来临时创建真实的Filter并把它添加到FilterChain中</p>\n<blockquote>\n<ul>\n<li>Config() 的目的是能让Filter Manager能够有机会把配置交给Factory（此时golang泛型还没有落地）</li>\n<li>Apply() 在配置被注入到Factory后，有机会对config做一些检查和提前做一些初始化的工作</li>\n<li>PrepareFilterChain() 创建Filter并加入Filter Chain</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// HttpFilterFactory describe http filter</span>\nHttpFilterFactory <span class=\"hljs-keyword\">interface</span> {\n   <span class=\"hljs-comment\">// Config Expose the config so that Filter Manger can inject it, so it must be a pointer</span>\n   Config() <span class=\"hljs-keyword\">interface</span>{}\n\n   <span class=\"hljs-comment\">// Apply After the config is injected, check it or make it to default</span>\n   Apply() error\n\n   <span class=\"hljs-comment\">// PrepareFilterChain create filter and append it to FilterChain</span>\n   <span class=\"hljs-comment\">//</span>\n   <span class=\"hljs-comment\">// Be Careful !!! Do not pass the Factory's config pointer to the Filter instance,</span>\n   <span class=\"hljs-comment\">// Factory's config may be updated by FilterManager</span>\n   PrepareFilterChain(ctx *http.HttpContext, chain FilterChain) error\n}\n</code></pre>\n<p><strong>Decode/Encode Filter：<strong>Filter分为两个部分，<strong>Decode</strong>在实际请求</strong>Upstream</strong>之前，所以可以做一些鉴权、限流，把请求在gateway层拦截掉。<strong>Eecode</strong>则运行在获得<strong>Upstream</strong>的Response之后，所以可以对返回Log甚至修改Response。</p>\n<blockquote>\n<p>一个Filter可以即是Decode Filter，又是Encode Filter，没有限制！</p>\n<p>假设有A、B、C三个Filter，都是Decode/Encode Filter，如果配置的顺序是A、B、C，那么运行将会是下面这样</p>\n<p>在Decode阶段 A-&gt;B-&gt;C，而在Encode阶段，顺序将会反过来！C-&gt;B-&gt;A</p>\n</blockquote>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// decode filters will be invoked in the config order: A、B、C, and decode filters will be</span>\n<span class=\"hljs-comment\">// invoked in the reverse order: C、B、A</span>\nHttpDecodeFilter <span class=\"hljs-keyword\">interface</span> {\n   Decode(ctx *http.HttpContext) FilterStatus\n}\n\n<span class=\"hljs-comment\">// HttpEncodeFilter after invoke upstream,</span>\n<span class=\"hljs-comment\">// decode filters will be invoked in the reverse order</span>\nHttpEncodeFilter <span class=\"hljs-keyword\">interface</span> {\n   Encode(ctx *http.HttpContext) FilterStatus\n}\n</code></pre>\n<p>更详细的，每个Decode/Encode Filter可以返回一个FilterStatus来决定继续还是就在这里停下！比如JWT鉴权，token无效时就要及时把401返回给Downstream。当然Decode Filter发出的停止命令只会终止Decode阶段，至于为什么？想想如何做一个Access Log Filter，能在请求失败时也把失败的结果记录下吧来！</p>\n<h2><strong>怎样编写一个自定义Filter</strong></h2>\n<p>我们来尝试写一个简单的Filter，这个Filter将会有简单的配置，在Decode阶段把请求的Body Log出来，并翻转后作为Mock的返回值。最后在Encode阶段根据配置把返回值Log出来。</p>\n<p>1.首先创建一个Filter</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> DemoFilter <span class=\"hljs-keyword\">struct</span> {\n   logPrefix <span class=\"hljs-keyword\">string</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(f *DemoFilter)</span> <span class=\"hljs-title\">Decode</span><span class=\"hljs-params\">(ctx *contexthttp.HttpContext)</span> <span class=\"hljs-title\">filter</span>.<span class=\"hljs-title\">FilterStatus</span></span> {\n   body, _ := ioutil.ReadAll(ctx.Request.Body)\n   logger.Infof(<span class=\"hljs-string\">\"request body: %s\"</span>, body)\n\n   <span class=\"hljs-comment\">//reverse res str</span>\n   runes := []<span class=\"hljs-keyword\">rune</span>(<span class=\"hljs-keyword\">string</span>(body))\n   <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(runes)/<span class=\"hljs-number\">2</span>; i += <span class=\"hljs-number\">1</span> {\n      runes[i], runes[<span class=\"hljs-built_in\">len</span>(runes)<span class=\"hljs-number\">-1</span>-i] = runes[<span class=\"hljs-built_in\">len</span>(runes)<span class=\"hljs-number\">-1</span>-i], runes[i]\n   }\n   reverse := <span class=\"hljs-keyword\">string</span>(runes)\n\n   <span class=\"hljs-comment\">//mock response</span>\n   ctx.SendLocalReply(<span class=\"hljs-number\">200</span>, []<span class=\"hljs-keyword\">byte</span>(reverse))\n   <span class=\"hljs-keyword\">return</span> filter.Stop\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(f *DemoFilter)</span> <span class=\"hljs-title\">Encode</span><span class=\"hljs-params\">(ctx *contexthttp.HttpContext)</span> <span class=\"hljs-title\">filter</span>.<span class=\"hljs-title\">FilterStatus</span></span> {\n   res := ctx.SourceResp.(<span class=\"hljs-keyword\">string</span>)\n   logger.Infof(<span class=\"hljs-string\">\"%s: %s\"</span>, f.logPrefix, res)\n   <span class=\"hljs-keyword\">return</span> filter.Continue\n}\n</code></pre>\n<p>2.创建Filter Factory</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> (\n\tDemoFilterFactory <span class=\"hljs-keyword\">struct</span> {\n\t\tconf *Config\n\t}\n\t<span class=\"hljs-comment\">// Config describe the config of Filter</span>\n\tConfig <span class=\"hljs-keyword\">struct</span> {\n\t\tLogPrefix <span class=\"hljs-keyword\">string</span> <span class=\"hljs-string\">`yaml:\"logPrefix,omitempty\"`</span>\n\t}\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(f *DemoFilterFactory)</span> <span class=\"hljs-title\">PrepareFilterChain</span><span class=\"hljs-params\">(ctx *contexthttp.HttpContext, chain filter.FilterChain)</span> <span class=\"hljs-title\">error</span></span> {\n   demo := &amp;DemoFilter{logPrefix: f.conf.LogPrefix}\n\n   chain.AppendDecodeFilters(demo)\n   chain.AppendEncodeFilters(demo)\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(f *DemoFilterFactory)</span> <span class=\"hljs-title\">Config</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">interface</span></span>{} {\n   <span class=\"hljs-keyword\">return</span> f.conf\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(f *DemoFilterFactory)</span> <span class=\"hljs-title\">Apply</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">error</span></span> {\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n}\n</code></pre>\n<p>3.创建Filter Plugin，并注册自己</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">//important</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span></span> {\n   filter.RegisterHttpFilter(&amp;Plugin{})\n}\n\n<span class=\"hljs-keyword\">type</span> Plugin <span class=\"hljs-keyword\">struct</span> {\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(p *Plugin)</span> <span class=\"hljs-title\">Kind</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> {\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"dgp.filters.demo\"</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(p *Plugin)</span> <span class=\"hljs-title\">CreateFilterFactory</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(filter.HttpFilterFactory, error)</span></span> {\n\t<span class=\"hljs-keyword\">return</span> &amp;DemoFilterFactory{conf: &amp;Config{}}, <span class=\"hljs-literal\">nil</span>\n}\n</code></pre>\n<p>4.配置文件中配置此Filter，并启动Pixiu</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">static_resources:</span>\n  <span class=\"hljs-attr\">listeners:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"net/http\"</span>\n      <span class=\"hljs-attr\">protocol_type:</span> <span class=\"hljs-string\">\"HTTP\"</span>\n      <span class=\"hljs-attr\">address:</span>\n        <span class=\"hljs-attr\">socket_address:</span>\n          <span class=\"hljs-attr\">address:</span> <span class=\"hljs-string\">\"0.0.0.0\"</span>\n          <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">8888</span>\n      <span class=\"hljs-attr\">filter_chains:</span>\n          <span class=\"hljs-attr\">filters:</span>\n            <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">dgp.filter.httpconnectionmanager</span>\n              <span class=\"hljs-attr\">config:</span>\n                <span class=\"hljs-attr\">route_config:</span>\n                  <span class=\"hljs-attr\">routes:</span>\n                    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">match:</span>\n                        <span class=\"hljs-attr\">prefix:</span> <span class=\"hljs-string\">\"/\"</span>\n                <span class=\"hljs-attr\">http_filters:</span>\n                  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">dgp.filters.demo</span>\n                    <span class=\"hljs-attr\">config:</span>\n</code></pre>\n<p>5.访问并查看日志与结果</p>\n<pre><code class=\"language-shell\">curl localhost:8888/demo -d \"eiv al tse’c\"\n\nc’est la vie% \n</code></pre>\n<p>日志</p>\n<pre><code>2022-02-19T20:20:11.900+0800    INFO    demo/demo.go:62 request body: eiv al tse’c\n2022-02-19T20:20:11.900+0800    INFO    demo/demo.go:71 : eiv al tse’c\n</code></pre>\n",
  "link": "/zh-cn/blog/filter-intro.html",
  "meta": {
    "title": "谈谈Pixiu的Filter",
    "keywords": "Pixiu 介绍",
    "description": "Filter通常是网关最重要的一部分，那Pixiu的过滤器链是如何运行的呢",
    "author": "@mark4z",
    "date": "2022-02-19"
  }
}