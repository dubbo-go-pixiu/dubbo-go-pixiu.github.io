<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="Seata、分布式事务、TCC" />
	<meta name="description" content="Seata 目前支持 AT 模式、XA 模式、TCC 模式和 SAGA 模式，之前文章更多谈及的是非侵入式的 AT 模式，今天带大家认识一下同样是二阶段提交的 TCC 模式。" />
	<!-- 网页标签标题 -->
	<title>深度剖析 Seata TCC 模式（一）</title>
  <link rel="shortcut icon" href="/img/pixiu-icon-small.png"/>
	<link rel="stylesheet" href="/build/blogDetail.css" />
</head>
<body>
	<div id="root"><div class="blog-detail-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="//img.alicdn.com/tfs/TB1gqL1w4D1gK0jSZFyXXciOVXa-1497-401.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="https://img.alicdn.com/tfs/TB14eEmw7P2gK0jSZPxXXacQpXa-38-32.png"/><ul><li class="menu-item menu-item-normal"><span><a href="/zh-cn/index.html">首页</a></span></li><li class="menu-item menu-item-normal"><span><a href="/zh-cn/docs/overview/what-is-pixiu.html">文档</a></span></li><li class="menu-item menu-item-normal"><span><a href="/zh-cn/docs/developers/developers_dev.html">开发者</a></span></li><li class="menu-item menu-item-normal menu-item-normal-active"><span><a href="/zh-cn/blog/index.html">博客</a></span></li><li class="menu-item menu-item-normal"><span><a href="/zh-cn/community/index.html">社区</a></span></li><li class="menu-item menu-item-normal"><span><a href="/zh-cn/blog/download.html">下载</a></span></li></ul></div></div></header><section class="blog-content markdown-body"><h1>前言</h1>
<p>Seata 目前支持 AT 模式、XA 模式、TCC 模式和 SAGA 模式，之前文章更多谈及的是非侵入式的 AT 模式，今天带大家认识一下同样是二阶段提交的 TCC 模式。</p>
<h1>什么是 TCC</h1>
<p>TCC 是分布式事务中的二阶段提交协议，它的全称为 Try-Confirm-Cancel，即资源预留（Try）、确认操作（Confirm）、取消操作（Cancel），他们的具体含义如下：</p>
<ol>
<li>Try：对业务资源的检查并预留；</li>
<li>Confirm：对业务处理进行提交，即 commit 操作，只要 Try 成功，那么该步骤一定成功；</li>
<li>Cancel：对业务处理进行取消，即回滚操作，该步骤回对 Try 预留的资源进行释放。</li>
</ol>
<p>TCC 是一种侵入式的分布式事务解决方案，以上三个操作都需要业务系统自行实现，对业务系统有着非常大的入侵性，设计相对复杂，但优点是 TCC
完全不依赖数据库，能够实现跨数据库、跨应用资源管理，对这些不同数据访问通过侵入式的编码方式实现一个原子操作，更好地解决了在各种复杂业务场景下的分布式事务问题。</p>
<p><img src="https://gitee.com/objcoding/md-picture/raw/master/img/20220116160157.png" alt=""></p>
<h1>Seata TCC 模式</h1>
<p>Seata TCC 模式跟通用型 TCC 模式原理一致，我们先来使用 Seata TCC 模式实现一个分布式事务：</p>
<p>假设现有一个业务需要同时使用服务 A 和服务 B 完成一个事务操作，我们在服务 A 定义该服务的一个 TCC 接口：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TccActionOne</span> </span>{
    <span class="hljs-meta">@TwoPhaseBusinessAction</span>(name = <span class="hljs-string">"DubboTccActionOne"</span>, commitMethod = <span class="hljs-string">"commit"</span>, rollbackMethod = <span class="hljs-string">"rollback"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">prepare</span><span class="hljs-params">(BusinessActionContext actionContext, @BusinessActionContextParameter(paramName = <span class="hljs-string">"a"</span>)</span> String a)</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">commit</span><span class="hljs-params">(BusinessActionContext actionContext)</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">rollback</span><span class="hljs-params">(BusinessActionContext actionContext)</span></span>;
}
</code></pre>
<p>同样，在服务 B 定义该服务的一个 TCC 接口：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TccActionTwo</span> </span>{
    <span class="hljs-meta">@TwoPhaseBusinessAction</span>(name = <span class="hljs-string">"DubboTccActionTwo"</span>, commitMethod = <span class="hljs-string">"commit"</span>, rollbackMethod = <span class="hljs-string">"rollback"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">(BusinessActionContext actionContext, @BusinessActionContextParameter(paramName = <span class="hljs-string">"b"</span>)</span> String b)</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">(BusinessActionContext actionContext)</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">(BusinessActionContext actionContext)</span></span>;
}
</code></pre>
<p>在业务所在系统中开启全局事务并执行服务 A 和服务 B 的 TCC 预留资源方法：</p>
<pre><code class="language-java"><span class="hljs-meta">@GlobalTransactional</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doTransactionCommit</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">//服务A事务参与者</span>
    tccActionOne.prepare(<span class="hljs-keyword">null</span>,<span class="hljs-string">"one"</span>);
    <span class="hljs-comment">//服务B事务参与者</span>
    tccActionTwo.prepare(<span class="hljs-keyword">null</span>,<span class="hljs-string">"two"</span>);
    }
</code></pre>
<p>以上就是使用 Seata TCC 模式实现一个全局事务的例子，可以看出，TCC 模式同样使用 <code>@GlobalTransactional</code> 注解开启全局事务，而服务 A 和服务 B 的 TCC 接口为事务参与者，Seata 会把一个 TCC
接口当成一个 Resource，也叫 TCC Resource。</p>
<p>TCC 接口可以是 RPC，也可以是 JVM 内部调用，意味着一个 TCC 接口，会有发起方和调用方两个身份，以上例子，TCC 接口在服务 A 和服务 B 中是发起方，在业务所在系统中是调用方。如果该 TCC 接口为 Dubbo
RPC，那么调用方就是一个 dubbo:reference，发起方则是一个 dubbo:service。</p>
<p><img src="https://gitee.com/objcoding/md-picture/raw/master/img/20220116161933.png" alt=""></p>
<p>Seata 启动时会对 TCC 接口进行扫描并解析，如果 TCC 接口是一个发布方，则在 Seata 启动时会向 TC 注册 TCC Resource，每个 TCC Resource 都有一个资源 ID；如果 TCC
接口时一个调用方，Seata 代理调用方，与 AT 模式一样，代理会拦截 TCC 接口的调用，即每次调用 Try 方法，会向 TC 注册一个分支事务，接着才执行原来的 RPC 调用。</p>
<p>当全局事务决议提交/回滚时，TC 会通过分支注册的的资源 ID 回调到对应参与者服务中执行 TCC Resource 的 Confirm/Cancel 方法。</p>
<h1>Seata 如何实现 TCC 模式</h1>
<p>从上面的 Seata TCC 模型可以看出，TCC 模式在 Seata 中也是遵循 TC、TM、RM 三种角色模型的，如何在这三种角色模型中实现 TCC 模式呢？我将其主要实现归纳为资源解析、资源管理、事务处理。</p>
<h2>资源解析</h2>
<p>资源解析即是把 TCC 接口进行解析并注册，前面说过，TCC 接口可以是 PRC，也可以是 JVM 内部调用，在 Seata TCC 模块中中一个 remoting
模块，该模块专门用于解析具有 <code>TwoPhaseBusinessAction</code> 注解的 TCC 接口资源：</p>
<p><img src="https://gitee.com/objcoding/md-picture/raw/master/img/20220116175059.png" alt=""></p>
<p><code>RemotingParser</code> 接口主要有 <code>isRemoting</code>、<code>isReference</code>、<code>isService</code>、<code>getServiceDesc</code> 等方法，默认的实现为 <code>DefaultRemotingParser</code>，其余各自的
RPC 协议解析类都在 <code>DefaultRemotingParser</code> 中执行，Seata 目前已经实现了对 Dubbo、HSF、SofaRpc、LocalTCC 的 RPC 协议的解析，同时具备 SPI 可扩展性，未来欢迎大家为
Seata 提供更多的 RPC 协议解析类。</p>
<p>在 Seata 启动过程中，有个 <code>GlobalTransactionScanner</code> 注解进行扫描，会执行以下方法：</p>
<p><code>io.seata.spring.util.TCCBeanParserUtils#isTccAutoProxy</code></p>
<p>该方法目的是判断 bean 是否已被 TCC 代理，在过程中会先判断 bean 是否是一个 Remoting bean，如果是则调用 <code>getServiceDesc</code> 方法对 remoting bean
进行解析，同时判断如果是一个发起方，则对其进行资源注册：</p>
<p>io.seata.rm.tcc.remoting.parser.DefaultRemotingParser#parserRemotingServiceInfo</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> RemotingDesc <span class="hljs-title">parserRemotingServiceInfo</span><span class="hljs-params">(Object bean,String beanName,RemotingParser remotingParser)</span></span>{
    RemotingDesc remotingBeanDesc=remotingParser.getServiceDesc(bean,beanName);
    <span class="hljs-keyword">if</span>(remotingBeanDesc==<span class="hljs-keyword">null</span>){
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
    remotingServiceMap.put(beanName,remotingBeanDesc);

    Class&lt;?&gt; interfaceClass=remotingBeanDesc.getInterfaceClass();
    Method[]methods=interfaceClass.getMethods();
    <span class="hljs-keyword">if</span>(remotingParser.isService(bean,beanName)){
    <span class="hljs-keyword">try</span>{
    <span class="hljs-comment">//service bean, registry resource</span>
    Object targetBean=remotingBeanDesc.getTargetBean();
    <span class="hljs-keyword">for</span>(Method m:methods){
    TwoPhaseBusinessAction twoPhaseBusinessAction=m.getAnnotation(TwoPhaseBusinessAction<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    <span class="hljs-keyword">if</span>(twoPhaseBusinessAction!=<span class="hljs-keyword">null</span>){
    TCCResource tccResource=<span class="hljs-keyword">new</span> TCCResource();
    tccResource.setActionName(twoPhaseBusinessAction.name());
    tccResource.setTargetBean(targetBean);
    tccResource.setPrepareMethod(m);
    tccResource.setCommitMethodName(twoPhaseBusinessAction.commitMethod());
    tccResource.setCommitMethod(interfaceClass.getMethod(twoPhaseBusinessAction.commitMethod(),
    twoPhaseBusinessAction.commitArgsClasses()));
    tccResource.setRollbackMethodName(twoPhaseBusinessAction.rollbackMethod());
    tccResource.setRollbackMethod(interfaceClass.getMethod(twoPhaseBusinessAction.rollbackMethod(),
    twoPhaseBusinessAction.rollbackArgsClasses()));
    <span class="hljs-comment">// set argsClasses</span>
    tccResource.setCommitArgsClasses(twoPhaseBusinessAction.commitArgsClasses());
    tccResource.setRollbackArgsClasses(twoPhaseBusinessAction.rollbackArgsClasses());
    <span class="hljs-comment">// set phase two method's keys</span>
    tccResource.setPhaseTwoCommitKeys(<span class="hljs-keyword">this</span>.getTwoPhaseArgs(tccResource.getCommitMethod(),
    twoPhaseBusinessAction.commitArgsClasses()));
    tccResource.setPhaseTwoRollbackKeys(<span class="hljs-keyword">this</span>.getTwoPhaseArgs(tccResource.getRollbackMethod(),
    twoPhaseBusinessAction.rollbackArgsClasses()));
    <span class="hljs-comment">//registry tcc resource</span>
    DefaultResourceManager.get().registerResource(tccResource);
    }
    }
    }<span class="hljs-keyword">catch</span>(Throwable t){
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FrameworkException(t,<span class="hljs-string">"parser remoting service error"</span>);
    }
    }
    <span class="hljs-keyword">if</span>(remotingParser.isReference(bean,beanName)){
    <span class="hljs-comment">//reference bean, TCC proxy</span>
    remotingBeanDesc.setReference(<span class="hljs-keyword">true</span>);
    }
    <span class="hljs-keyword">return</span> remotingBeanDesc;
    }
</code></pre>
<p>以上方法，先调用解析类 <code>getServiceDesc</code> 方法对 remoting bean 进行解析，并将解析后的 <code>remotingBeanDesc</code> 放入 本地缓存 <code>remotingServiceMap</code>
中，同时调用解析类 <code>isService</code> 方法判断是否为发起方，如果是发起方，则解析 <code>TwoPhaseBusinessAction</code> 注解内容生成一个 <code>TCCResource</code>，并对其进行资源注册。</p>
<h2>资源管理</h2>
<p><strong>1、资源注册</strong></p>
<p>Seata TCC 模式的资源叫 <code>TCCResource</code>，其资源管理器叫 <code>TCCResourceManager</code>，前面讲过，当解析完 TCC 接口 RPC 资源后，如果是发起方，则会对其进行资源注册：</p>
<p>io.seata.rm.tcc.TCCResourceManager#registerResource</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerResource</span><span class="hljs-params">(Resource resource)</span></span>{
    TCCResource tccResource=(TCCResource)resource;
    tccResourceCache.put(tccResource.getResourceId(),tccResource);
    <span class="hljs-keyword">super</span>.registerResource(tccResource);
    }
</code></pre>
<p><code>TCCResource</code> 包含了 TCC 接口的相关信息，同时会在本地进行缓存。继续调用父类 <code>registerResource</code> 方法（封装了通信方法）向 TC 注册，TCC 资源的 resourceId 是
actionName，actionName 就是 <code>@TwoParseBusinessAction</code> 注解中的 name。</p>
<p><strong>2、资源提交/回滚</strong></p>
<p>io.seata.rm.tcc.TCCResourceManager#branchCommit</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> BranchStatus <span class="hljs-title">branchCommit</span><span class="hljs-params">(BranchType branchType,String xid,<span class="hljs-keyword">long</span> branchId,String resourceId,
    String applicationData)</span><span class="hljs-keyword">throws</span> TransactionException</span>{
    TCCResource tccResource=(TCCResource)tccResourceCache.get(resourceId);
    <span class="hljs-keyword">if</span>(tccResource==<span class="hljs-keyword">null</span>){
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ShouldNeverHappenException(String.format(<span class="hljs-string">"TCC resource is not exist, resourceId: %s"</span>,resourceId));
    }
    Object targetTCCBean=tccResource.getTargetBean();
    Method commitMethod=tccResource.getCommitMethod();
    <span class="hljs-keyword">if</span>(targetTCCBean==<span class="hljs-keyword">null</span>||commitMethod==<span class="hljs-keyword">null</span>){
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ShouldNeverHappenException(String.format(<span class="hljs-string">"TCC resource is not available, resourceId: %s"</span>,resourceId));
    }
    <span class="hljs-keyword">try</span>{
    <span class="hljs-comment">//BusinessActionContext</span>
    BusinessActionContext businessActionContext=getBusinessActionContext(xid,branchId,resourceId,
    applicationData);
    <span class="hljs-comment">// ... ... </span>
    ret=commitMethod.invoke(targetTCCBean,args);
    <span class="hljs-comment">// ... ... </span>
    <span class="hljs-keyword">return</span> result?BranchStatus.PhaseTwo_Committed:BranchStatus.PhaseTwo_CommitFailed_Retryable;
    }<span class="hljs-keyword">catch</span>(Throwable t){
    String msg=String.format(<span class="hljs-string">"commit TCC resource error, resourceId: %s, xid: %s."</span>,resourceId,xid);
    LOGGER.error(msg,t);
    <span class="hljs-keyword">return</span> BranchStatus.PhaseTwo_CommitFailed_Retryable;
    }
    }
</code></pre>
<p>当 TM 决议二阶段提交，TC 会通过分支注册的的资源 ID 回调到对应参与者（即 TCC 接口发起方）服务中执行 TCC Resource 的 Confirm/Cancel 方法。</p>
<p>资源管理器中会根据 resourceId 在本地缓存找到对应的 <code>TCCResource</code>，同时根据 xid、branchId、resourceId、applicationData 找到对应的 <code>BusinessActionContext</code>
上下文，执行的参数就在上下文中。最后，执行 <code>TCCResource</code> 中获取 <code>commit</code> 的方法进行二阶段提交。</p>
<p>二阶段回滚同理类似。</p>
<h2>事务处理</h2>
<p>前面讲过，如果 TCC 接口时一个调用方，则会使用 Seata TCC 代理对调用方进行拦截处理，并在处理调用真正的 RPC 方法前对分支进行注册。</p>
<p>执行方法<code>io.seata.spring.util.TCCBeanParserUtils#isTccAutoProxy</code>除了对 TCC 接口资源进行解析，还会判断 TCC 接口是否为调用方，如果是调用方则返回 true：</p>
<p>io.seata.spring.annotation.GlobalTransactionScanner#wrapIfNecessary</p>
<p><img src="https://gitee.com/objcoding/md-picture/raw/master/img/20220116192544.png" alt=""></p>
<p>如图，当 <code>GlobalTransactionalScanner</code> 扫描到 TCC 接口调用方（Reference）时，会使 <code>TccActionInterceptor</code> 对其进行代理拦截处理，<code>TccActionInterceptor</code>
实现 <code>MethodInterceptor</code>。</p>
<p>在 <code>TccActionInterceptor</code> 中还会调用 <code>ActionInterceptorHandler</code> 类型执行拦截处理逻辑，事务相关处理就在 <code>ActionInterceptorHandler#proceed</code> 方法中：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">proceed</span><span class="hljs-params">(Method method,Object[]arguments,String xid,TwoPhaseBusinessAction businessAction,
    Callback&lt;Object&gt; targetCallback)</span><span class="hljs-keyword">throws</span> Throwable</span>{
    <span class="hljs-comment">//Get action context from arguments, or create a new one and then reset to arguments</span>
    BusinessActionContext actionContext=getOrCreateActionContextAndResetToArguments(method.getParameterTypes(),arguments);
    <span class="hljs-comment">//Creating Branch Record</span>
    String branchId=doTccActionLogStore(method,arguments,businessAction,actionContext);
    <span class="hljs-comment">// ... ... </span>
    <span class="hljs-keyword">try</span>{
    <span class="hljs-comment">// ... ...</span>
    <span class="hljs-keyword">return</span> targetCallback.execute();
    }<span class="hljs-keyword">finally</span>{
    <span class="hljs-keyword">try</span>{
    <span class="hljs-comment">//to report business action context finally if the actionContext.getUpdated() is true</span>
    BusinessActionContextUtil.reportContext(actionContext);
    }<span class="hljs-keyword">finally</span>{
    <span class="hljs-comment">// ... ... </span>
    }
    }
    }
</code></pre>
<p>以上，在执行 TCC 接口一阶段之前，会调用 <code>doTccActionLogStore</code> 方法分支注册，同时还会将 TCC 相关信息比如参数放置在上下文，上面讲的资源提交/回滚就会用到这个上下文。</p>
<h1>如何控制异常</h1>
<p>在 TCC 模型执行的过程中，还可能会出现各种异常，其中最为常见的有空回滚、幂等、悬挂等。下面我讲下 Seata 是如何处理这三种异常的。</p>
<h2>如何处理空回滚</h2>
<p>什么是空回滚？</p>
<p>空回滚指的是在一个分布式事务中，在没有调用参与方的 Try 方法的情况下，TM 驱动二阶段回滚调用了参与方的 Cancel 方法。</p>
<p>那么空回滚是如何产生的呢？</p>
<p><img src="https://gitee.com/objcoding/md-picture/raw/master/img/20220116201900.png" alt=""></p>
<p>如上图所示，全局事务开启后，参与者 A 分支注册完成之后会执行参与者一阶段 RPC 方法，如果此时参与者 A 所在的机器发生宕机，网络异常，都会造成 RPC 调用失败，即参与者 A 一阶段方法未成功执行，但是此时全局事务已经开启，Seata
必须要推进到终态，在全局事务回滚时会调用参与者 A 的 Cancel 方法，从而造成空回滚。</p>
<p>要想防止空回滚，那么必须在 Cancel 方法中识别这是一个空回滚，Seata 是如何做的呢？</p>
<p>Seata 的做法是新增一个 TCC 事务控制表，包含事务的 XID 和 BranchID 信息，在 Try 方法执行时插入一条记录，表示一阶段执行了，执行 Cancel 方法时读取这条记录，如果记录不存在，说明 Try 方法没有执行。</p>
<h2>如何处理幂等</h2>
<p>幂等问题指的是 TC 重复进行二阶段提交，因此 Confirm/Cancel 接口需要支持幂等处理，即不会产生资源重复提交或者重复释放。</p>
<p>那么幂等问题是如何产生的呢？</p>
<p><img src="https://gitee.com/objcoding/md-picture/raw/master/img/20220116203816.png" alt=""></p>
<p>如上图所示，参与者 A 执行完二阶段之后，由于网络抖动或者宕机问题，会造成 TC 收不到参与者 A 执行二阶段的返回结果，TC 会重复发起调用，直到二阶段执行结果成功。</p>
<p>Seata 是如何处理幂等问题的呢？</p>
<p>同样的也是在 TCC 事务控制表中增加一个记录状态的字段 status，该字段有有 3 个值，分别为：</p>
<ol>
<li>tried：1</li>
<li>committed：2</li>
<li>rollbacked：3</li>
</ol>
<p>二阶段 Confirm/Cancel 方法执行后，将状态改为 committed 或 rollbacked 状态。当重复调用二阶段 Confirm/Cancel 方法时，判断事务状态即可解决幂等问题。</p>
<h2>如何处理悬挂</h2>
<p>悬挂指的是二阶段 Cancel 方法比 一阶段 Try 方法优先执行，由于允许空回滚的原因，在执行完二阶段 Cancel 方法之后直接空回滚返回成功，此时全局事务已结束，但是由于 Try 方法随后执行，这就会造成一阶段 Try
方法预留的资源永远无法提交和释放了。</p>
<p>那么悬挂是如何产生的呢？</p>
<p><img src="https://gitee.com/objcoding/md-picture/raw/master/img/20220116205241.png" alt=""></p>
<p>如上图所示，在执行参与者 A 的一阶段 Try 方法时，出现网路拥堵，由于 Seata 全局事务有超时限制，执行 Try 方法超时后，TM 决议全局回滚，回滚完成后如果此时 RPC 请求才到达参与者 A，执行 Try
方法进行资源预留，从而造成悬挂。</p>
<p>Seata 是怎么处理悬挂的呢？</p>
<p>在 TCC 事务控制表记录状态的字段 status 中增加一个状态：</p>
<ol>
<li>suspended：4</li>
</ol>
<p>当执行二阶段 Cancel 方法时，如果发现 TCC 事务控制表有相关记录，说明二阶段 Cancel 方法优先一阶段 Try 方法执行，因此插入一条 status=4 状态的记录，当一阶段 Try 方法后面执行时，判断 status=4
，则说明有二阶段 Cancel 已执行，并返回 false 以阻止一阶段 Try 方法执行成功。</p>
<h1>作者简介</h1>
<p>张乘辉，目前就职于蚂蚁集团，热爱分享技术，微信公众号「后端进阶」作者，技术博客（<a href="https://objcoding.com/">https://objcoding.com/</a>）博主，Seata Committer，GitHub
ID：objcoding。</p>
</section><footer class="footer-container"><div class="footer-body"><img src="//img.alicdn.com/tfs/TB1dGrSwVT7gK0jSZFpXXaTkpXa-4802-1285.png"/><p class="docsite-power">website powered by docsite</p><div class="cols-container"><div class="col col-12"><h3>愿景</h3><p>Pixiu 是一款 Dubbo 生态下的高性能 API 网关和多语言解决方案 Sidecar</p></div><div class="col col-6"><dl><dt>ASF</dt><dd><a href="http://www.apache.org/" target="_self">基金会</a></dd><dd><a href="http://www.apache.org/licenses/" target="_self">证书</a></dd><dd><a href="http://www.apache.org/events/current-event" target="_self">事件</a></dd><dd><a href="http://www.apache.org/foundation/sponsorship.html" target="_self">赞助</a></dd><dd><a href="http://www.apache.org/foundation/thanks.html" target="_self">赞助</a></dd></dl></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/overview/what-is-pixiu.html" target="_self">Pixiu 是什么？</a></dd><dd><a href="/zh-cn/docs/user/quickstart.html" target="_self">快速开始</a></dd><dd><a href="https://github.com/dubbogo/pixiu.github.io/issues/new" target="_self">报告文档问题</a></dd><dd><a href="https://github.com/dubbogo/pixiu.github.io" target="_self">在Github上编辑此文档</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2021 Seata</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/blogDetail.js"></script>
	<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?104e73ef0c18b416b27abb23757ed8ee";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
</body>
</html>
