{
  "filename": "http-to-dubbo-default-stragety.md",
  "__html": "<h1>背景</h1>\n<p>​\t通过 Http 提供一个统一的服务提供者视图，用户不用在乎后端Dubbo服务的版本差异，协议差异，通过简单地在Http请求中传递rpc调用的参数，完成一次Rpc调用，通过实现http调用后端dubbo服务，进一步简化后端服务设计的复杂性。</p>\n<h1>目的</h1>\n<p>​\t统一Http调用后端dubbo服务的形式，方便网关产品实现 Http 调用转 dubbo 调用的实现，Dubbo能和网关更好的融合。</p>\n<h1>Conception</h1>\n<h2>Dubbo RPC 调用的基本形式</h2>\n<p><img src=\"/img/user/appendix/img1.png\" alt=\"img\"></p>\n<p>希望通过提供Http调用Dubbo的方式简化 Consumer 的Rpc调用流程</p>\n<p><img src=\"/img/user/appendix/img2.png\" alt=\"img\"></p>\n<p>网关会在整个服务调用的过程中承担更多的原本客户端的功能，比如负载均衡，服务治理，安全等能力，外部用户调用服务的时候将更多的关注与调用本身。</p>\n<h2>Http request 和 Http response 的格式</h2>\n<p>request的URL和Header中包含RPC调用的元信息，包含服务名，方法名，服务分组，服务版本，request 的 body 中包含请求的参数，参数是 <strong>json list</strong> 的格式, 如果没有参数则为 <em><strong>null</strong></em></p>\n<p>http response 中包含请求的处理状态，返回结果或者调用的错误类型以及错误具体信息，返回的body中只包含一个 <em><strong>json object</strong></em>，这个object中包含 <em><strong>code</strong></em>，<em><strong>result</strong></em>，<em><strong>error</strong></em></p>\n<p>通过 code 表示返回的具体状态，result 和 error 在返回中只会返回其中一个，分别是调用的返回结果，调用返回的错误信息。</p>\n<h3>Http request</h3>\n<h4>Http 请求的方法</h4>\n<p>只能为 <strong>POST</strong> 方法</p>\n<h4>Http 请求的 URL</h4>\n<p>格式：<a href=\"http://host/service/method\">http://host/ {service} / {method</a>} or <a href=\"https://host/service/method\">https://host/ {service} / {method</a>}</p>\n<ul>\n<li>service 是调用的服务名，对应于Dubbo message body中的 service Name</li>\n<li>method 是调用的方法名，对应于Dubbo message body中的 method Name</li>\n</ul>\n<p>服务名和方法名都应该和后端服务的声明一致</p>\n<p>如果URL中无法获取到service和method，应该直接返回</p>\n<table>\n<thead>\n<tr>\n<th>http code</th>\n<th>code</th>\n<th>detail</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>400</td>\n<td>3</td>\n<td>service or method not provided</td>\n</tr>\n</tbody>\n</table>\n<h4>Http 请求的Header</h4>\n<p>Header中必须包含以下条目：</p>\n<ul>\n<li>x-dubbo-http1.1-dubbo-version</li>\n</ul>\n<p>表明这个Http 请求是一个Http转dubbo的请求，目前支持Dubbo 协议和 triple 协议，可配置的选项为：</p>\n<ul>\n<li>\n<ul>\n<li>x-dubbo-http1.1-dubbo-version: triple</li>\n<li>x-dubbo-http1.1-dubbo-version: dubbo</li>\n</ul>\n</li>\n</ul>\n<p>​      前者表示这是转化为triple协议，后者表示转化为dubbo协议</p>\n<p>可选参数：</p>\n<ul>\n<li>x-dubbo-service-version 如果提供了应该填充到Dubbo message 的Serviceversion字段中.</li>\n<li>x-dubbo-service-group  如果提供了应该在attachment 添加 group 字段并把对应的值进行填充。</li>\n</ul>\n<h4>Http 请求的Body</h4>\n<p>body中包含请求的参数，body中只包含一个 <em><strong>Json object</strong></em> 对象</p>\n<p>这个对象目前包含两个字段：</p>\n<ul>\n<li>param</li>\n</ul>\n<p>param 的值类型为 list，标识调用方法的参数，顺序和方法签名中的参数顺序一致</p>\n<p>这里使用object组装请求参数是为了协议能够向后兼容，body中的对象可能会增加新的字段。</p>\n<h5>基本类型在 Json Java Go 中的映射关系</h5>\n<table>\n<thead>\n<tr>\n<th>Json Type</th>\n<th>Java Type</th>\n<th>Golang Type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Integer</td>\n<td>java.lang.Long</td>\n<td>int64</td>\n</tr>\n<tr>\n<td>Double</td>\n<td>java.lang.Double</td>\n<td>float64</td>\n</tr>\n<tr>\n<td>String</td>\n<td>java.lang.String</td>\n<td>string</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>null</td>\n<td>nil</td>\n</tr>\n<tr>\n<td>Bool</td>\n<td>java.lang.Boolean</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>List</td>\n<td>java.lang.List</td>\n<td>silice</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>java.lang.Map</td>\n<td>map</td>\n</tr>\n</tbody>\n</table>\n<p>通过对基本类型映射关系的定义简化网关配置，对于只使用基本配置的转化，网关应该可以在不使用额外配置的情况下完成转化的</p>\n<h5>Body 处理异常时的处理策略</h5>\n<ol>\n<li>调用方提供的请求参数 Json 解析错误，返回状态码 400</li>\n<li>调用的时候，无法确定参数的具体类型，例如，用户使用的自定义类型，但是没有在网关配置具体的类型名，应该返回状态码 400</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>http code</th>\n<th>code</th>\n<th>detail</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>400</td>\n<td>3</td>\n<td>argument parse error</td>\n</tr>\n<tr>\n<td>400</td>\n<td>3</td>\n<td>argument type info not found</td>\n</tr>\n</tbody>\n</table>\n<p>在以上条件都符合时，一个Http 调用可以被转化成为 Dubbo 协议的调用，只要网关能够成功进行请求的转化，则网关回复调用方的时候，Http 状态码都应该是 200 OK，至于调用方调用后端服务出现错误的信息，应该放在 body 中的 code 以及 error 字段中。</p>\n<h3>http response</h3>\n<p>在请求经过后端返回之后，需要将一下信息传递给调用方：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>status</td>\n<td>返回的状态，在dubbo response 的header的status 中</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>调用成功返回的结果，如果没有返回值，则result 的值为 null</td>\n</tr>\n<tr>\n<td>返回异常</td>\n<td>调用失败，产生异常，返回异常的具体message</td>\n</tr>\n</tbody>\n</table>\n<p>返回值和返回异常只能出现一项</p>\n<p>code 和 grpc 中的 status code 一致 详细的 code 及其含义见 <a href=\"https://grpc.github.io/grpc/core/md_doc_statuscodes.html\">https://grpc.github.io/grpc/core/md_doc_statuscodes.html</a></p>\n<h4>返回异常的处理：</h4>\n<p>dubbo 中的异常以hessian2 的 class 类型返回，返沪的error中只需要对应的message 字段即可</p>\n<h2>Dubbo 协议的具体转化</h2>\n<h3>Dubbo 协议的具体介绍 可以见文章</h3>\n<p><a href=\"https://dubbo.apache.org/en/blog/2018/10/05/introduction-to-the-dubbo-protocol/\">https://dubbo.apache.org/en/blog/2018/10/05/introduction-to-the-dubbo-protocol/</a></p>\n<h3>Dubbo 协议的 message 格式</h3>\n<p><img src=\"https://dubbo.apache.org/imgs/dev/dubbo_protocol_header.png\" alt=\"img\"></p>\n<h4>Dubbo Header的封装要求</h4>\n<table>\n<thead>\n<tr>\n<th>bits</th>\n<th>Name</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0 - 15</td>\n<td>Magic Number</td>\n<td>必须为 0xdabb</td>\n</tr>\n<tr>\n<td>16</td>\n<td>message 的类型</td>\n<td>必须为 1 （request）</td>\n</tr>\n<tr>\n<td>17</td>\n<td>2-way</td>\n<td>必须为 1 （需要服务端返回值）</td>\n</tr>\n<tr>\n<td>18</td>\n<td>Event</td>\n<td>必须为 0 不支持事件类型</td>\n</tr>\n<tr>\n<td>19 - 23</td>\n<td>序列化类型</td>\n<td>可以扩展实现Hessian，Json等序列化类型，类型编号如下表</td>\n</tr>\n<tr>\n<td>24 - 31</td>\n<td>Status</td>\n<td>表示 response 的状态，见Status 处理要求</td>\n</tr>\n<tr>\n<td>32 - 95</td>\n<td>Request Id</td>\n<td>客户端的请求ID，可以根据需要自行定义</td>\n</tr>\n<tr>\n<td>96 - 127</td>\n<td>Data length</td>\n<td>请求体的长度，请求体的大小</td>\n</tr>\n</tbody>\n</table>\n<p>序列化类型编号：</p>\n<table>\n<thead>\n<tr>\n<th>Serialization Type</th>\n<th>Code</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Hessian2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Java</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Compact Java</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Fast Json</td>\n<td>6</td>\n</tr>\n<tr>\n<td>Native Java</td>\n<td>7</td>\n</tr>\n</tbody>\n</table>\n<p>请求Header中的字段应该以大端的形式封装，发送到服务端</p>\n<h4>Dubbo Body</h4>\n<p>请求的body应该包含以下内容：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Dubbo Version</td>\n<td>根据网关的配置，或者Http请求获取</td>\n</tr>\n<tr>\n<td>Service Name</td>\n<td>服务名</td>\n</tr>\n<tr>\n<td>Method Name</td>\n<td>调用方法名，采用泛化调用的方式，此项目固定为“$invoke”</td>\n</tr>\n<tr>\n<td>Method parameter types</td>\n<td>参数类型，泛化调用有固定值 &quot;Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/Object;&quot;</td>\n</tr>\n<tr>\n<td>Method arguments</td>\n<td>使用配置的序列化方式将对应的参数序列化，按照用户传入的参数的顺序放入参数</td>\n</tr>\n</tbody>\n</table>\n<p>以上的各个项目在使用了指定的序列化形式之后，按照上表指定的顺序进行序列化。</p>\n<p>attachment 目前不转化</p>\n<p><em><strong>注意</strong></em>：</p>\n<p>使用文本类型的序列化（Json） 在每一个序列化对象后边要加上行分割符( <em><strong>&quot;\\n&quot;</strong></em> or <em><strong>&quot;\\r\\n&quot;</strong></em> )</p>\n<p>Java 中在使用FastJson 编解码的时候使用了BufferedReader，每次取buffer中的对象的时候，会先调用BufferReader的readLine方法，此方法分割行依靠 ‘/n’ ， ’/r/n‘</p>\n<p>以下给出了Dubbo 协议中返回header中的status对应于GRPC status的对应列表</p>\n<h5>Status 的处理</h5>\n<p>Dubbo resposne status 中，OK延续使用grpc的 OK code，其余的 status Number编号紧接着 grpc 的16个 code进行编号</p>\n<p>对应的error详情是 response 中异常的 message。</p>\n<table>\n<thead>\n<tr>\n<th>Dubbo State</th>\n<th>Number</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ResponseStatus::Ok</td>\n<td>0</td>\n</tr>\n<tr>\n<td>ResponseStatus::ClientTimeout</td>\n<td>130</td>\n</tr>\n<tr>\n<td>ResponseStatus::ServerTimeout</td>\n<td>131</td>\n</tr>\n<tr>\n<td>ResponseStatus::ServiceNotFound</td>\n<td>12</td>\n</tr>\n<tr>\n<td>ResponseStatus::ServerThreadpoolExhaustedError</td>\n<td>13</td>\n</tr>\n<tr>\n<td>ResponseStatus::ClientError</td>\n<td>\\</td>\n</tr>\n<tr>\n<td>ResponseStatus::ServerError</td>\n<td>13</td>\n</tr>\n<tr>\n<td>ResponseStatus::ServiceError</td>\n<td>13</td>\n</tr>\n<tr>\n<td>ResponseStatus::BadResponse</td>\n<td>13</td>\n</tr>\n<tr>\n<td>ResponseStatus::BadRequest</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<h2>Triple 协议的具体转化</h2>\n<p>Triple 是基于GRPC的，定义在Http2 协议之上</p>\n<h3>Triple中RPC调用的元信息</h3>\n<h4>Triple 通过 URL 传递调用的服务名和方法名</h4>\n<p>格式： <a href=\"http://host/service/method\">http://host/ {service} / {method</a>}</p>\n<p>我们的规范兼容 Triple 通过http2传递参数的形式，尽量做到dubbo 和 triple 的统一。</p>\n<h4>Header Frame</h4>\n<p>header 中应该包含以下条目</p>\n<ul>\n<li>Content-Type：<em><strong>application/grpc-proto</strong></em></li>\n</ul>\n<p>标识这是一个 triple 协议的rpc调用</p>\n<ul>\n<li>x-dubbo-service-group</li>\n</ul>\n<p>指明调用的服务的分组</p>\n<ul>\n<li>x-dubbo-service-version</li>\n</ul>\n<p>指明调用的服务的版本</p>\n<h4>Data frame</h4>\n<p>Triple协议将请求参数放在Body中，在triple中，如果服务中的方法定义能够使用pb序列化，则只有一层序列化，如果需要用到其他的序列化，则需要使用TripleRequestWrapper</p>\n<p>对参数进行包装。</p>\n<p>我们推广使用 <em><strong>Triple + pb</strong></em> 的序列化形式，服务的提供方需要给出服务的 proto 定义，对于triple协议网关对于***triple + pb***  的转化是比较容易实现的，如果用户没有提供proto定义，需要返回信息：</p>\n<table>\n<thead>\n<tr>\n<th>http code</th>\n<th>code</th>\n<th>detail</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>400</td>\n<td>3</td>\n<td>argument type info not found</td>\n</tr>\n</tbody>\n</table>\n<h3></h3>\n",
  "link": "/zh-cn/docs/user/appendix/http-to-dubbo-default-stragety.html",
  "meta": {
    "title": "HTTP to Dubbo 默认转换协议 v0.0.1",
    "keywords": "Dubbo",
    "description": "HTTP to Dubbo 默认转换协议"
  }
}